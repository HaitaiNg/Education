Pointer machine data structure 
Linked list, binary search tree 

Temporal data structures: 
-Persistence data structures: where you do not forget anything 
-Keeps all versions of data structure
-All data structures are relative to a specified version 
-the update makes and returns a new version 

4 levels of resistance: 
1.) partial persistence : easiest to obtain 
-update latest version 
-versions are linearly ordered 
2.) Full persistence model: you can update anything you want. Update any version 
The versions form a tree 
3.) Confluent persistence: combine two versions to create a new version. (new version). Versions form a DAG 

linked list + linked list 
bst + bst 
4.) Functional persistence: you can never modify anything 
You cannot modify any nodes. You can only create new nodes. (Is block chain like functional persistence, since you cannot modify the ledger?) 
 
Partial persistence: 
any pointer machine data structure with <p = O(1) pointers to any node to any can be transformed to another data structure that is partially persistent with constant O(1) amortized factor overhead 
O(1) added space / change in the data structure 
Backtracking using pointers. Reference history 

Full Persistence: Everything has to change, back pointers, modifications. 
It has back pointers to ALL versions in a linear tree form. Use tree traversals 

Order maintenance DS : Variation of a linked list 
insert item before / after given item  O(1) 
relative order of two items O(1)

——————
Confluent persistence: In U updates -> N * size of data structure 
Concatenating strings to itself multiple times 

General Transform e(v) = 1 + log(# paths from root to v)
overhead: log(u) + max(e(v) + time & space) 

lower bound: sum of (bits of space) 
 
——————
Disjoint transform: If you assume confluent operations are performed only on two versions with no shared nodes.Then you can get O(log(n)) overhead 
