Memory Management 

Local address space that is bound to a separate physical address space.
Logical Address : generated by the CPU; virtual address 
Physical Address: address seen by the memory unit 

Logical and Physical addresses are the same in compile-time and load-time address building schemes; logical (virtual) and physical addresses differ in execution-time address-binding scheme

Memory Management is comprised of the following steps: 
-Relocatable : program image can reside anywhere in physical memory 
-Binding: program requires real memory in order to reside. (Mapping logical to physical addresses) / Binding can be done at compile / link time. 
-Compiler: Defines where the program will reside. 
-Load: binds relocatable to physical. 
-Execution: code can be moved during execution 

Dynamic loading: 
-Routine is not loaded until called
-Better memory-space utilization
-Useful when large amounts of code are needed to handle infrequently occurring cases 
-No special support from the OS is required - implemented through program design 

Dynamic linking: 
-Linking postponed until execution time 
-Small pieces of code, stub, used to locate the appropriate memory-resident library routine
-Stub replaces itself with the address of the routine, and executes the routine
-Operating System needed to check if route is in processes memory addresses 

Partitions: division of physical memory into fixed sized regions. (Allows addresses spaces to be distinct = one user can’t muck with another user or the system. 

How do you allocate memory to new processes?
-First fit: allocate the first hole that is large enough
-Best fit: allocate smallest hole that is large enough
-Worst fit: allocate largest hole

SMALL holes can lead to external fragmentation
LARGE holes can lead to internal fragmentation 

If  a job does not fit in memory,  the scheduler can -wait for memory
-skip to next job and see if it fits 
PRO: no internal fragmentation 
CON: external fragmentation can occur. This is because the memory is constantly being handed cyber between the processes and free

COMPACTION algorithm: trying to move free memory to one large block; Swapping: if using static relocation, code /data must return to same place. Dynamic can reenter at a more advantageous memory 

PAGING Algorithm: 
-Divide physical memory into fixed sized blocks called frames 
-Divide logical memory into fixed sized blocks called pages 
-keep track of all free frames 
-to run a program of size n pages, need to find n free frames and load program 
-set up a page table to translate logical to physical addresses 
-internal fragmentation 

How are addresses translated? 
-Each address is generated by the CPU and is divided into two parts:
	-Page number : index into page table (contains base address of each page in physical memory) 
	-Page offset: combined with base address to define the physical memory address that is sent to the memory unit 

PAGING: permits a program’s memory to by physically noncontiguous so it can be allocated from wherever available. This avoids fragmentation and compaction 

Frames = physical blocks
Pages = logical blocks 
Size of frames are determined by the hardware 

SEGMENTATION:A programmer’s views a process based on components. (global variables; procedure call stack; code for each function; logical variables for each; large data structures) 

Logical Address = segment name (number) + offset 

Paging: associating logical with physical memory 

Memory Management 

Local address space that is bound to a separate physical address space.
Logical Address : generated by the CPU; virtual address 
Physical Address: address seen by the memory unit 

Logical and Physical addresses are the same in compile-time and load-time address building schemes; logical (virtual) and physical addresses differ in execution-time address-binding scheme

Memory Management is comprised of the following steps: 
-Relocatable : program image can reside anywhere in physical memory 
-Binding: program requires real memory in order to reside. (Mapping logical to physical addresses) / Binding can be done at compile / link time. 
-Compiler: Defines where the program will reside. 
-Load: binds relocatable to physical. 
-Execution: code can be moved during execution 

Dynamic loading: 
-Routine is not loaded until called
-Better memory-space utilization
-Useful when large amounts of code are needed to handle infrequently occurring cases 
-No special support from the OS is required - implemented through program design 

Dynamic linking: 
-Linking postponed until execution time 
-Small pieces of code, stub, used to locate the appropriate memory-resident library routine
-Stub replaces itself with the address of the routine, and executes the routine
-Operating System needed to check if route is in processes memory addresses 

Partitions: division of physical memory into fixed sized regions. (Allows addresses spaces to be distinct = one user can’t muck with another user or the system. 

How do you allocate memory to new processes?
-First fit: allocate the first hole that is large enough
-Best fit: allocate smallest hole that is large enough
-Worst fit: allocate largest hole

SMALL holes can lead to external fragmentation
LARGE holes can lead to internal fragmentation 

If  a job does not fit in memory,  the scheduler can -wait for memory
-skip to next job and see if it fits 
PRO: no internal fragmentation 
CON: external fragmentation can occur. This is because the memory is constantly being handed cyber between the processes and free

COMPACTION algorithm: trying to move free memory to one large block; Swapping: if using static relocation, code /data must return to same place. Dynamic can reenter at a more advantageous memory 

PAGING Algorithm: 
-Divide physical memory into fixed sized blocks called frames 
-Divide logical memory into fixed sized blocks called pages 
-keep track of all free frames 
-to run a program of size n pages, need to find n free frames and load program 
-set up a page table to translate logical to physical addresses 
-internal fragmentation 

How are addresses translated? 
-Each address is generated by the CPU and is divided into two parts:
	-Page number : index into page table (contains base address of each page in physical memory) 
	-Page offset: combined with base address to define the physical memory address that is sent to the memory unit 

PAGING: permits a program’s memory to by physically noncontiguous so it can be allocated from wherever available. This avoids fragmentation and compaction 

Frames = physical blocks
Pages = logical blocks 
Size of frames are determined by the hardware 

SEGMENTATION:A programmer’s views a process based on components. (global variables; procedure call stack; code for each function; logical variables for each; large data structures) 

Logical Address = segment name (number) + offset 

Paging: associating logical with physical memory 

Virtual memory is a system by which the machine or operating system fools processes running on the machine into thinking that they have a lot more memory to work with than the capacity of RAM would indicate. It does this by storing most recently used items in RAM and storing the lesser used items in the slower disk memory

Virtual memory is comprised of there parts: main memory + pages + disk 
Main memory = RAM, holds chunks (pages) of memory 
Secondary memory = DISK = stores chunks (pages) not being used. 
Page Table = tells us where on the disk or in RAM the particular chunk of data we’re looking for is 

MAIN MEMORY: Contains the most recently used pages. Each page is stored into subdivisions of memory called ‘frames’ 
SECONDARY MEMORY (DISK): repository for pages not ins use. When a page needs to be brought to the memory, the appropriate page is found and transferred to main memory. Whenever a page the has been modified during its time in main memory, it is written to disk. 
PAGE TABLE: Keeps track of where pages are and what their properties are. 
	-PAGE TABLE CONTAINS:
		valid bit, dirty bit, access control, frame number, disk location 

Once all this detail is taken care of, the formula for deriving the actual physical address from the virtual address is simple. You take the virtual address, extract the virtual page number, look up the corresponding entry in the page table, and in the virtual address replace the virtual page number with the frame number. Voilà. You have the physical address. Once this translation is made and we're assured that the data we want is in main memory, it may be accessed without any trouble.

Partition memory into small equal fixed size chunks called page frames 
Processes divided into pages as well
Page frames and pages are of equal size 
Operating system maintains a page table for each process 
-Contains the frame location for each page in the process 
-Memory address consist of a page number and offset within the page 

In unix, each process has a data segment 
In C++, new and delete == malloc and free 
Memory management is an example of a doubly linked list. They call it a free list. 
 
Unusable space in the form of holes is called external fragmentation, while unused space inside allocated blocks is called internal fragmentation.

Compaction handles fragmentation by moving all the allocated blocks to one end of memory, thus combining all the holes. 
Compaction occurs in three phases: 
	-new location of each block is calculated to determine the distance the block will be moved 
	-each pointer is updated by adding to it the amount that the block it is point (n) to will be moved 
	-data is moved 

Paging: Memory management unit (sits in the CPU and the memory unit) 
-When CPU wants to access memory (load an instruction / load / store data) it sends the desired memory address to the MMU.
MMU transit it to another address before passing to the memory unit. Address generated by the CPU is the virtual address and the address gets translated by the MMU, creating the physical address 

Memory address -> MMU -> CPU creates Virtual address -> MMU takes virtual address and creates physical  address 

MMU contains a page table ( array of entries indexed by page number). Each entry contains flags and frame number 
