Memory Management 

Local address space that is bound to a separate physical address space.
Logical Address : generated by the CPU; virtual address 
Physical Address: address seen by the memory unit 

Logical and Physical addresses are the same in compile-time and load-time address building schemes; logical (virtual) and physical addresses differ in execution-time address-binding scheme

Memory Management is comprised of the following steps: 
-Relocatable : program image can reside anywhere in physical memory 
-Binding: program requires real memory in order to reside. (Mapping logical to physical addresses) / Binding can be done at compile / link time. 
-Compiler: Defines where the program will reside. 
-Load: binds relocatable to physical. 
-Execution: code can be moved during execution 

Dynamic loading: 
-Routine is not loaded until called
-Better memory-space utilization
-Useful when large amounts of code are needed to handle infrequently occurring cases 
-No special support from the OS is required - implemented through program design 

Dynamic linking: 
-Linking postponed until execution time 
-Small pieces of code, stub, used to locate the appropriate memory-resident library routine
-Stub replaces itself with the address of the routine, and executes the routine
-Operating System needed to check if route is in processes memory addresses 

Partitions: division of physical memory into fixed sized regions. (Allows addresses spaces to be distinct = one user can’t muck with another user or the system. 

How do you allocate memory to new processes?
-First fit: allocate the first hole that is large enough
-Best fit: allocate smallest hole that is large enough
-Worst fit: allocate largest hole

SMALL holes can lead to external fragmentation
LARGE holes can lead to internal fragmentation 

If  a job does not fit in memory,  the scheduler can -wait for memory
-skip to next job and see if it fits 
PRO: no internal fragmentation 
CON: external fragmentation can occur. This is because the memory is constantly being handed cyber between the processes and free

COMPACTION algorithm: trying to move free memory to one large block; Swapping: if using static relocation, code /data must return to same place. Dynamic can reenter at a more advantageous memory 

PAGING Algorithm: 
-Divide physical memory into fixed sized blocks called frames 
-Divide logical memory into fixed sized blocks called pages 
-keep track of all free frames 
-to run a program of size n pages, need to find n free frames and load program 
-set up a page table to translate logical to physical addresses 
-internal fragmentation 

How are addresses translated? 
-Each address is generated by the CPU and is divided into two parts:
	-Page number : index into page table (contains base address of each page in physical memory) 
	-Page offset: combined with base address to define the physical memory address that is sent to the memory unit 

PAGING: permits a program’s memory to by physically noncontiguous so it can be allocated from wherever available. This avoids fragmentation and compaction 

Frames = physical blocks
Pages = logical blocks 
Size of frames are determined by the hardware 

SEGMENTATION: A programmer’s views a process based on components. (global variables; procedure call stack; code for each function; logical variables for each; large data structures) 

Logical Address = segment name (number) + offset 

Paging: associating logical with physical memory 

